
**Don’t communicate by sharing memory; share memory by communicating.**  
（不要通过共享内存来通信，而应该通过通信来共享内存。）

执行业务处理的 goroutine 不要通过共享内存的方式通信，而是要通过 Channel 通信的方式分享数据。

[channel的底层实现](https://github.com/golang/go/blob/master/src/runtime/chan.go#L32)

## channel的使用
~~~~
通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。
通道的容量，是指通道最多可以缓存多少个元素值, 不能小于0。
当容量为0时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。
而当容量大于0时，我们可以称为缓冲通道，也就是带有缓冲的通道。
非缓冲通道和缓冲通道有着不同的数据传递方式。
~~~~

### 单向通道
单向通道就是只能发不能收，或者只能收不能发的通道。  
一个通道是双向的，还是单向的是由它的类型字面量体现的。  
chan<- 表示这个通道是单向的，并且只能发而不能收。  
<-chan 表示这个通道是单向的，并且只能发收而不能发。  
这里的“发”和“收”都是站在操作通道的代码的角度上说的。  
单向通道最主要的用途就是约束其他代码的行为。
```gotemplate
chan struct{} // 可以发送接收
chan<- struct{} // 只能发送
<-chan int // 只能从chan接收
```


### 通道的容量

~~~~
通过 make，我们可以初始化一个 chan，未初始化的 chan 的零值是 nil。
可以设置它的容量，比如下面的 chan 的容量是 9527，我们把这样的 chan 叫做 buffered chan；
如果没有设置，它的容量是 0，我们把这样的 chan 叫做 unbuffered chan。
~~~~
```go
make(chan int, 9527)
```
**nil 是 chan 的零值，是一种特殊的 chan，对值是 nil 的 chan 的发送接收调用者总是会阻塞。**


## 通道的基本特性如下： 
1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。
2. 发送操作和接收操作中对元素值的处理都是不可分割的。
3. 发送操作在完全完成之前会被阻塞。接收操作也是如此。

~~~~
对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。
例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，但是这时它绝不会被想接收它的一方看到和取走。
~~~~

**这里要注意的一个细节是，元素值从外界进入通道时会被复制。
更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。**

~~~~
元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，
第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，
第二步是删除在通道中的这个元素值。
一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。
在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。
更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的 goroutine，以使它去争取继续运行代码的机会。
另外，接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。
在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。
~~~~

**如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。**

### 发送操作和接收操作在什么时候可能被长时间的阻塞？
~~~~
先说针对缓冲通道的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。
这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。
由于发送操作在这种情况下被阻塞后，它们所在的 goroutine 会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。
相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。
这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。
因此而等待的、所有接收操作所在的 goroutine，都会按照先后顺序被放入通道内部的接收等待队列。

对于非缓冲通道，情况要简单一些。
无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。
由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。
并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。
相比之下，缓冲通道则在用异步的方式传递数据。

在大多数情况下，缓冲通道会作为收发双方的中间件。
正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。
但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。

以上说的都是在正确使用通道的前提下会发生的事情。下面我特别说明一下，由于错误使用通道而造成的阻塞。
对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。
它们所属的 goroutine 中的任何代码，都不再会被执行。
注意，由于通道类型是引用类型，所以它的零值就是nil。
换句话说，当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。
我们一定不要忘记初始化通道！
~~~~

### 发送操作和接收操作在什么时候会引发 panic？
~~~~

对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。
另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。
具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定bool类型。
它的值如果为false就说明通道已经关闭，并且再没有元素值可取了。
注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true。
因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。
由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。
~~~~
**不要让接收方关闭通道，应该让发送方关闭通道。**



### channel的应用场景
1. 数据交流 
~~~
当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。
多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。
~~~
2. 数据传递
~~~
一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。
~~~
3. 信号通知
~~~
一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine 。
~~~
4. 任务编排
~~~
可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。
~~~
5. 任务编排
~~~
利用 Channel 也可以实现互斥锁的机制。
~~~

## 使用Channel常见的错误
### panic
* close 为 nil 的 chan；
* send 已经 close 的 chan；
* close 已经 close 的 chan；

### goroutine 泄漏


### select语句与通道的联用
select语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的代码会被运行。
select语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。
候选分支总是以关键字case开头，后跟一个case表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句。
默认分支其实就是 default case，因为，当且仅当没有候选分支被选中时它才会被执行，所以它以关键字default开头并直接后跟一个冒号。
同样的，我们可以在default:的下一行写入要执行的语句。
由于select语句是专为通道而设计的，所以每个case表达式中都只能包含操作通道的表达式，比如接收表达式。

在使用select语句的时候需要注意的地方：
1. 如果加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，select语句都不会被阻塞。
   如果那几个表达式都阻塞了，或者说都没有满足求值的条件，那么默认分支就会被选中并执行。
2. 如果没有加入默认分支，那么一旦所有的case表达式都没有满足求值条件，那么select语句就会被阻塞。直到至少有一个case表达式满足条件为止。
3. 我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。
   所以，在很多时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。
   一旦发现某个通道关闭了，我们就应该及时地屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。
4. select语句只能对其中的每一个case表达式各求值一次。
   所以，如果我们想连续或定时地操作其中的通道的话，就往往需要通过在for语句中嵌入select语句的方式实现。
   但这时要注意，简单地在select语句的分支中使用break语句，只能结束当前的select语句的执行，而并不会对外层的for语句产生作用。
   这种错误的用法可能会让这个for语句无休止地运行下去。


### select语句的分支选择规则
1. 对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。
   比如，如果case表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。
   当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。

## 到底使用chan还是并发原语

* 共享资源的并发访问使用传统并发原语；
* 复杂的任务编排和消息传递使用 Channel；
* 消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；
* 简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；
* 需要和 Select 语句结合，使用 Channel；
* 需要和超时配合时，使用 Channel 和 Context。


