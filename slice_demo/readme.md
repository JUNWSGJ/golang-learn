
### 数组的长度是固定的，而切片是可变长的
~~~~
可以把切片看做是对数组的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含一个数组。

数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。
~~~~

~~~~
通过调用内建函数len，得到数组和切片的长度。
通过调用内建函数cap，我们可以得到它们的容量。
数组的容量永远等于其长度，都是不可变的
~~~~

### 切片的扩容
~~~~
一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。
但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。
在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。
但是，当原切片的长度（以下简称原长度）大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准（以下新容量基准）
。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。
最终，新容量往往会比新长度大一些，当然，相等也是可能的。
更多细节参见runtime包中 slice.go 文件里的growslice及相关函数的具体实现。
~~~~

### 切片的底层数组什么时候会被替换？
~~~~
确切地说，一个切片的底层数组永远不会被替换。为什么？
虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片
它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。
在无需扩容时，append函数返回的是指向原底层数组的原切片，
而在需要扩容时，append函数返回的是指向新底层数组的新切片。
~~~~